# -*- Autotest -*-

AT_BANNER([problem data])

## ---------------- ##
## add_to_problem_data ##
## ---------------- ##

AT_TESTFUN([add_to_problem_data],
[[
#include "problem_data.h"
#include "internal_libreport.h"
#include <assert.h>

#define TEST_NAME "package"
#define TEST_CONTENTS "libreport"
#define TEST_FLAGS (CD_FLAG_TXT | CD_FLAG_ISNOTEDITABLE)

int main(int argc, char **argv)
{
    g_verbose = 3;

    problem_data_t *data = new_problem_data();
    add_to_problem_data(data, TEST_NAME, TEST_CONTENTS);

    struct problem_item *itm = get_problem_data_item_or_NULL(data, TEST_NAME);

    assert(strcmp(itm->content, TEST_CONTENTS) == 0);
    assert(itm->flags == TEST_FLAGS);

    free_problem_data(data);

    return 0;
}
]])

## -------------------- ##
## add_to_problem_data_ext ##
## -------------------- ##

AT_TESTFUN([add_to_problem_data_ext],
[[
#include "problem_data.h"
#include "internal_libreport.h"
#include <assert.h>

#define TEST_NAME "package"
#define TEST_CONTENTS "libreport"
#define TEST_FLAGS (CD_FLAG_TXT | CD_FLAG_ISNOTEDITABLE | CD_FLAG_UNIXTIME)

int main(int argc, char **argv)
{
    g_verbose = 3;

    problem_data_t *data = new_problem_data();

    add_to_problem_data_ext(data, TEST_NAME, TEST_CONTENTS, TEST_FLAGS);
    struct problem_item *found = get_problem_data_item_or_NULL(data, TEST_NAME);
    assert(found != NULL);

    assert(strcmp(found->content, TEST_CONTENTS) == 0);
    assert(found->flags == TEST_FLAGS);

    free_problem_data(data);

    return 0;
}
]])


## ------------------------------- ##
## load_problem_data_from_dump_dir ##
## ------------------------------- ##

AT_TESTFUN([load_problem_data_from_dump_dir],
[[
#include "problem_data.h"
#include "internal_libreport.h"
#include <assert.h>

int main(int argc, char **argv)
{
    g_verbose = 3;

    char template[] = "/tmp/XXXXXX";

    if (mkdtemp(template) == NULL) {
        perror("mkdtemp()");
        return EXIT_FAILURE;
    }

    printf("Dump dir path: %s\n", template);

    struct dump_dir *dd = dd_create(template, (uid_t)-1, 0640);
    assert(dd != NULL || !"Cannot create new dump directory");

    /* dd_create_basic_files() should create these files:
       FILENAME_TIME, FILENAME_LAST_OCCURRENCE, FILENAME_UID, FILENAME_KERNEL,
       FILENAME_ARCHITECTURE, FILENAME_HOSTNAME, FILENAME_OS_INFO, FILENAME_OS_RELEASE
     */
    dd_create_basic_files(dd, geteuid(), NULL);

    dd_save_text(dd, FILENAME_TYPE, "attest");
    dd_save_text(dd, FILENAME_ANALYZER, "attest-problem_data");
    dd_save_text(dd, FILENAME_DUPHASH, "0123456789ABCDEF");
    dd_save_text(dd, FILENAME_UUID, "FEDCBA9876543210");
    dd_save_text(dd, FILENAME_USERNAME, "perhaps_tester");
    dd_save_text(dd, FILENAME_PACKAGE, "1:attest-1.1-3.x86_64");
    dd_save_text(dd, FILENAME_PKG_EPOCH, "1");
    dd_save_text(dd, FILENAME_PKG_NAME, "attest");
    dd_save_text(dd, FILENAME_PKG_VERSION, "1.1");
    dd_save_text(dd, FILENAME_PKG_RELEASE, "3");
    dd_save_text(dd, FILENAME_PKG_ARCH, "x86_64");
    dd_save_text(dd, FILENAME_CMDLINE, "$TESTSUITE.DIR/$NUM/load_problem_data_from_dump_dir foo blah");
    dd_save_text(dd, FILENAME_EXECUTABLE, "$TESTSUITE.DIR/$NUM/load_problem_data_from_dump_dir");
    dd_save_text(dd, FILENAME_ROOTDIR, "/");
    dd_save_text(dd, FILENAME_PWD, "$TESTSUITE.DIR");
    dd_save_text(dd, FILENAME_PID, "12345");
    dd_save_text(dd, FILENAME_COUNT, "1");
    dd_save_text(dd, FILENAME_REASON, "Unit testing load_problem_data_from_dump_dir");
    dd_save_text(dd, FILENAME_COMMENT, "Random comment");
    dd_save_text(dd, FILENAME_BACKTRACE, "Pseudo-backtrace");
    dd_save_text(dd, FILENAME_OPEN_FDS, "Opened FDs");
    dd_save_text(dd, FILENAME_MAPS, "/proc/[pid]/maps");
    dd_save_text(dd, FILENAME_SMAPS, "/proc/[pid]/smaps");
    dd_save_text(dd, FILENAME_ENVIRON, "/proc/[pid]/environ");
    dd_save_text(dd, FILENAME_LIMITS, "/proc/[pid]/limits");
    dd_save_text(dd, FILENAME_CGROUP, "/proc/[pid]/cgroup");
    dd_save_text(dd, FILENAME_PROC_PID_STATUS, "/proc/[pid]/status");
    dd_save_text(dd, FILENAME_CRASH_FUNCTION, "main");
    dd_save_text(dd, FILENAME_REMOTE, "0");
    dd_save_text(dd, FILENAME_RATING, "4");
    dd_save_text(dd, FILENAME_TAINTED, "Not tainted");
    dd_save_text(dd, FILENAME_TAINTED_SHORT, "Not tainted");
    dd_save_text(dd, FILENAME_TAINTED_LONG, "Not tainted");
    dd_save_text(dd, FILENAME_NOT_REPORTABLE, "Despite 'not tainted' this problem cannot be reported.");
    dd_save_text(dd, FILENAME_REPORTED_TO, "Bugzilla: URL=https://bugzilla.redhat.com/1000000");
    dd_save_text(dd, FILENAME_EVENT_LOG, "--- report_Bugzilla has finished successfully ---");

    dd_save_text(dd, FILENAME_KERNEL_LOG, "FILENAME_KERNEL_LOG");
    dd_save_text(dd, FILENAME_DESCRIPTION, "FILENAME_DESCRIPTION");
    dd_save_text(dd, FILENAME_CORE_BACKTRACE, "FILENAME_CORE_BACKTRACE");
    dd_save_text(dd, FILENAME_REMOTE_RESULT, "FILENAME_REMOTE_RESULT");
    dd_save_text(dd, FILENAME_ABRT_VERSION, "FILENAME_ABRT_VERSION");

    dd_save_text(dd, "attestsuite-random-file", "random content");
    dd_save_text(dd, "attestsuite-oneliner-newline", "newline\n");
    dd_save_text(dd, "attestsuite-newline-followed", "newline\nfollowed");
    dd_save_text(dd, "attestsuite-multi-line", "newline\nextra\n");
    dd_save_text(dd, "attestsuite-tab", "tab\ttab");
    dd_save_text(dd, "attestsuite-cr", "cr\rcr");

    char buffer[1024*3];
    memset(buffer, 'x', sizeof(buffer));

    {
        int fd4k = openat(dd->dd_fd, "attestsuite-over4k", O_WRONLY | O_CREAT | O_TRUNC, 0550);
        assert(fd4k >= 0);
        full_write(fd4k, buffer, sizeof(buffer));
        full_write(fd4k, buffer, sizeof(buffer));
        close(fd4k);
    }

    {
        int bigfd = openat(dd->dd_fd, "attestsuite-bigtext", O_WRONLY | O_CREAT | O_TRUNC, 0550);
        assert(bigfd >= 0);
        for (int i = 3000; i > 0; --i)
            full_write(bigfd, buffer, sizeof(buffer));
        close(bigfd);
    }

    char *dst;

    dst = concat_path_file(dd->dd_dirname, FILENAME_BINARY);
    copy_file_recursive("/bin/sh", dst);
    free(dst);

    dst = concat_path_file(dd->dd_dirname, FILENAME_COREDUMP);
    copy_file_recursive("/bin/sh", dst);
    free(dst);

    dst = concat_path_file(dd->dd_dirname, FILENAME_VMCORE);
    copy_file_recursive("/bin/sh", dst);
    free(dst);

    static const char *const list_elements[] = { FILENAME_UID, FILENAME_PACKAGE,
        FILENAME_EXECUTABLE, FILENAME_TIME, FILENAME_COUNT };

    static const char *const editable_files[] = { FILENAME_COMMENT, FILENAME_BACKTRACE,
        FILENAME_REASON, FILENAME_OPEN_FDS, FILENAME_CMDLINE, FILENAME_MAPS,
        FILENAME_SMAPS, FILENAME_ENVIRON, FILENAME_HOSTNAME, FILENAME_REMOTE, };

    static const char *const binary_files[] = { FILENAME_BINARY, FILENAME_COREDUMP,
        FILENAME_VMCORE, };

    problem_data_t *pd = new_problem_data();
    load_problem_data_from_dump_dir(pd, dd, /*excluding*/NULL);

    GHashTableIter pd_iter;
    char *element_name;
    struct problem_item *item;
    g_hash_table_iter_init(&pd_iter, pd);
    while (g_hash_table_iter_next(&pd_iter, (void**)&element_name, (void**)&item))
    {
        printf("Testing element : %s\n", element_name);

        size_t i;
        for (i = 0; i < ARRAY_SIZE(list_elements); ++i)
        {
            if (strcmp(element_name, list_elements[i]) == 0)
            {
                assert((item->flags & CD_FLAG_LIST));
                break;
            }
        }
        if (i == ARRAY_SIZE(list_elements))
            assert(!(item->flags & CD_FLAG_LIST));

        for (i = 0; i < ARRAY_SIZE(editable_files); ++i)
        {
            if (strcmp(element_name, editable_files[i]) == 0)
            {
                assert((item->flags & CD_FLAG_ISEDITABLE) && !(item->flags & CD_FLAG_ISNOTEDITABLE));
                break;
            }
        }
        if (i == ARRAY_SIZE(editable_files))
            assert(!(item->flags & CD_FLAG_ISEDITABLE) && (item->flags & CD_FLAG_ISNOTEDITABLE));

        for (i = 0; i < ARRAY_SIZE(binary_files); ++i)
        {
            if (strcmp(element_name, binary_files[i]) == 0)
            {
                assert((item->flags & CD_FLAG_BIN) && !(item->flags & CD_FLAG_TXT));
                break;
            }
        }
        if (i == ARRAY_SIZE(binary_files))
        {
            if(strstr(element_name, "bigtext") == 0)
                assert((item->flags & CD_FLAG_TXT) && !(item->flags & CD_FLAG_BIN));
            else
                assert((item->flags & CD_FLAG_BIN) && !(item->flags & CD_FLAG_TXT));
        }

        if (strcmp(element_name, FILENAME_TIME) == 0)
            assert(item->flags & CD_FLAG_UNIXTIME);
        else
            assert(!(item->flags & CD_FLAG_UNIXTIME));
    }

    {
        const char *cnt = get_problem_item_content_or_NULL(pd, "attestsuite-oneliner-newline");
        assert(cnt != NULL && "attestsuite-oneliner-newline");
        assert(strcmp(cnt, "newline") == 0);
    }

    {
        const char *cnt = get_problem_item_content_or_NULL(pd, "attestsuite-newline-followed");
        assert(cnt != NULL && "attestsuite-newline-followed");
        assert(strcmp(cnt, "newline\nfollowed") == 0);
    }

    {
        const char *cnt = get_problem_item_content_or_NULL(pd, "attestsuite-multi-line");
        assert(cnt != NULL && "attestsuite-multi-line");
        assert(strcmp(cnt, "newline\nextra\n") == 0);
    }

    {
        const char *cnt = get_problem_item_content_or_NULL(pd, "attestsuite-over4k");
        assert(cnt != NULL && "attestsuite-over4k");
        assert(strlen(cnt) == (2 * sizeof(buffer)));
    }

    {
        const char *cnt = get_problem_item_content_or_NULL(pd, "attestsuite-tab");
        assert(cnt != NULL && "attestsuite-tab");
        assert(strcmp(cnt, "tab\ttab") == 0);
    }

    {
        const char *cnt = get_problem_item_content_or_NULL(pd, "attestsuite-cr");
        assert(cnt != NULL && "attestsuite-cr");
        assert(strcmp(cnt, "cr[0D]cr") == 0);
    }

    return 0;
}
]])

## ------------------------- ##
## problem_data_reproducible ##
## ------------------------- ##

AT_TESTFUN([problem_data_reproducible],
[[
#include "testsuite.h"
TS_MAIN
{
    TS_ASSERT_STRING_NULL_OR_EMPTY(get_problem_data_reproducible_name(-1), "Invalid value");
    TS_ASSERT_PTR_IS_NOT_NULL(get_problem_data_reproducible_name(PROBLEM_REPRODUCIBLE_UNKNOWN));
    TS_ASSERT_PTR_IS_NOT_NULL(get_problem_data_reproducible_name(PROBLEM_REPRODUCIBLE_YES));
    TS_ASSERT_PTR_IS_NOT_NULL(get_problem_data_reproducible_name(PROBLEM_REPRODUCIBLE_RECURRENT));
    TS_ASSERT_STRING_NULL_OR_EMPTY(get_problem_data_reproducible_name(_PROBLEM_REPRODUCIBLE_MAX_), "Upper boundary");
    TS_ASSERT_STRING_NULL_OR_EMPTY(get_problem_data_reproducible_name(_PROBLEM_REPRODUCIBLE_MAX_ + 1), "Upper boundary + 1");
    TS_ASSERT_SIGNED_EQ(_PROBLEM_REPRODUCIBLE_MAX_, 3);

    problem_data_t *pd = new_problem_data();

    TS_ASSERT_SIGNED_EQ(get_problem_data_reproducible(pd), -1);

    add_to_problem_data(pd, FILENAME_REPRODUCIBLE, get_problem_data_reproducible_name(PROBLEM_REPRODUCIBLE_UNKNOWN));
    TS_ASSERT_SIGNED_EQ(get_problem_data_reproducible(pd), PROBLEM_REPRODUCIBLE_UNKNOWN);

    add_to_problem_data(pd, FILENAME_REPRODUCIBLE, get_problem_data_reproducible_name(PROBLEM_REPRODUCIBLE_YES));
    TS_ASSERT_SIGNED_EQ(get_problem_data_reproducible(pd), PROBLEM_REPRODUCIBLE_YES);

    add_to_problem_data(pd, FILENAME_REPRODUCIBLE, get_problem_data_reproducible_name(PROBLEM_REPRODUCIBLE_RECURRENT));
    TS_ASSERT_SIGNED_EQ(get_problem_data_reproducible(pd), PROBLEM_REPRODUCIBLE_RECURRENT);

    add_to_problem_data(pd, FILENAME_REPRODUCIBLE, get_problem_data_reproducible_name(_PROBLEM_REPRODUCIBLE_MAX_));
    TS_ASSERT_SIGNED_EQ(get_problem_data_reproducible(pd), -1);

    free_problem_data(pd);
}
TS_RETURN_MAIN
]])
