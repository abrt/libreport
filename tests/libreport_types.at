# -*- Autotest -*-

AT_BANNER([libreport types])

## ------------- ##
## string_vector ##
## ------------- ##

AT_TESTFUN([string_vector],
[[
#include "internal_libreport.h"
#include <assert.h>

int main(int argc, char **argv)
{
    libreport_g_verbose = 3;

    const char *const raw_value = "foo, blah, bang";
    string_vector_ptr_t vector = g_strsplit(raw_value, ", ", 0);

    assert(strcmp("foo", vector[0]) == 0 || !"The first item");
    assert(strcmp("blah", vector[1]) == 0 || !"The second item");
    assert(strcmp("bang", vector[2]) == 0 || !"The third item");
    assert(NULL == vector[3] || !"NULL-terminated");

    g_strfreev(vector);

    vector = g_strsplit("", ", ", 0);
    assert(NULL == vector[0] || !"NULL-terminated");

    g_strfreev(vector);

    vector = g_strsplit("", ", ", 0);
    assert(NULL == vector[0] || !"NULL-terminated");

    g_strfreev(vector);
}
]])

## ----------------------------------- ##
## map_string_get_set_as_various_types ##
## ----------------------------------- ##

AT_TESTFUN([map_string_get_set_as_various_types],
[[
#include "internal_libreport.h"
#include <assert.h>

int main(int argc, char **argv)
{
    libreport_g_verbose = 3;

    {
        const char *const key = "my_bool";
        map_string_t *map = g_hash_table_new_full(g_str_hash, g_str_equal, free, free);

        int retval = 0;

        assert(!libreport_try_get_map_string_item_as_bool(map, key, &retval) || !"Returns bool(0) even if option does not exist");
        assert(retval == 0 || !"Modifies bool(0) return value on failure");

        retval = 1;

        assert(!libreport_try_get_map_string_item_as_bool(map, key, &retval) || !"Returns bool(1) even if option does not exist");
        assert(retval == 1 || !"Modifies bool(1) return value on failure");

        libreport_set_map_string_item_from_bool(map, key, 1);
        assert(g_hash_table_lookup(map, key) || !"Set bool(1)");
        assert(strcmp("yes", g_hash_table_lookup(map, key)) == 0 || !"Invalid string repr for bool(1)");
        assert(libreport_try_get_map_string_item_as_bool(map, key, &retval) || !"Failed to return bool(1)");
        assert(retval || !"Failed to convert 'yes' to bool(1)");

        libreport_set_map_string_item_from_bool(map, key, 0);
        assert(g_hash_table_lookup(map, key) || !"Set bool(0)");
        assert(strcmp("no", g_hash_table_lookup(map, key)) == 0 || !"Invalid string repr for bool(0)");
        retval = 1;
        assert(libreport_try_get_map_string_item_as_bool(map, key, &retval) || !"Failed to return bool(0)");
        assert(!retval || !"Failed to convert 'no' to bool(0)");

        g_hash_table_replace(map, g_strdup(key), g_strdup("foo"));
        retval = 1;
        assert(libreport_try_get_map_string_item_as_bool(map, key, &retval) || !"Can not convert a random string to bool(0)");
        assert(!retval || !"Failed to convert a random string to bool(0)");

        if (map)
            g_hash_table_destroy(map);
    }

    {
        const char *const key = "my_int";
        map_string_t *map = g_hash_table_new_full(g_str_hash, g_str_equal, free, free);

        int retval = INT_MIN;

        assert(!libreport_try_get_map_string_item_as_int(map, key, &retval) || !"Returns INT_MIN even if option does not exist");
        assert(retval == INT_MIN || !"Modifies INT_MIN value on failure");

        retval = INT_MAX;

        assert(!libreport_try_get_map_string_item_as_int(map, key, &retval) || !"Returns INT_MAX even if option does not exist");
        assert(retval == INT_MAX || !"Modifies INT_MAX value on failure");

        libreport_set_map_string_item_from_int(map, key, 12345);
        assert(g_hash_table_lookup(map, key) || !"Set int(12345)");
        assert(strcmp("12345", g_hash_table_lookup(map, key)) == 0 || !"Invalid string repr for int(12345)");
        assert(libreport_try_get_map_string_item_as_int(map, key, &retval) || !"Failed to return int(12345)");
        assert(12345 == retval || !"Failed to convert '12345' to int(12345)");

        libreport_set_map_string_item_from_int(map, key, -12345);
        assert(g_hash_table_lookup(map, key) || !"Set int(-12345)");
        assert(strcmp("-12345", g_hash_table_lookup(map, key)) == 0 || !"Invalid string repr for int(-12345)");
        assert(libreport_try_get_map_string_item_as_int(map, key, &retval) || !"Failed to return int(-12345)");
        assert(-12345 == retval || !"Failed to convert '-12345' to int(-12345)");

        libreport_set_map_string_item_from_int(map, key, INT_MAX);
        assert(libreport_try_get_map_string_item_as_int(map, key, &retval) || !"Cannot return INT_MAX");
        assert(retval == INT_MAX || !"Garbled INT_MAX");

        libreport_set_map_string_item_from_int(map, key, INT_MIN);
        assert(libreport_try_get_map_string_item_as_int(map, key, &retval) || !"Cannot return INT_MIN");
        assert(retval == INT_MIN || !"Garbled INT_MIN");

        retval = 69;
        g_hash_table_replace(map, g_strdup(key), g_strdup(""));
        assert(!libreport_try_get_map_string_item_as_int(map, key, &retval) || !"Converts '' to number");
        assert(retval == 69 || !"Modifies int(69) on ''");

        g_hash_table_replace(map, g_strdup(key), g_strdup("foo"));
        assert(!libreport_try_get_map_string_item_as_int(map, key, &retval) || !"Converts 'foo' to number");
        assert(retval == 69 || !"Modifies int(69) on 'foo'");

        g_hash_table_replace(map, g_strdup(key), g_strdup("777foo"));
        assert(!libreport_try_get_map_string_item_as_int(map, key, &retval) || !"Converts '777foo' to number");
        assert(retval == 69 || !"Modifies int(69) on '777foo'");

                                                 /*0123456789ABCDEF*/
        g_hash_table_replace(map, g_strdup(key), g_strdup("77777777777777777777777777777777"));
        assert(!libreport_try_get_map_string_item_as_int(map, key, &retval) || !"Converts '77777777777777777777777777777777' to number");
        assert(retval == 69 || !"Modifies int(69) on '77777777777777777777777777777777'");

        if (map)
            g_hash_table_destroy(map);
    }

    {
        const char *const key = "my_uint";
        map_string_t *map = g_hash_table_new_full(g_str_hash, g_str_equal, free, free);

        unsigned int retval = 0;

        assert(!libreport_try_get_map_string_item_as_uint(map, key, &retval) || !"Returns 0 even if option does not exist");
        assert(retval == 0 || !"Modifies 0 value on failure");

        retval = UINT_MAX;

        assert(!libreport_try_get_map_string_item_as_uint(map, key, &retval) || !"Returns UINT_MAX even if option does not exist");
        assert(retval == UINT_MAX || !"Modifies UINT_MAX value on failure");

        libreport_set_map_string_item_from_uint(map, key, 12345);
        assert(g_hash_table_lookup(map, key) || !"Set uint(12345)");
        assert(strcmp("12345", g_hash_table_lookup(map, key)) == 0 || !"Invalid string repr for uint(12345)");
        assert(libreport_try_get_map_string_item_as_uint(map, key, &retval) || !"Failed to return uint(12345)");
        assert(12345 == retval || !"Failed to convert '12345' to uint(12345)");

        libreport_set_map_string_item_from_uint(map, key, INT_MAX + 1);
        assert(g_hash_table_lookup(map, key) || !"Set INT_MAX + 1");
        assert(libreport_try_get_map_string_item_as_uint(map, key, &retval) || !"Failed to return int(INT_MAX + 1)");
        assert(INT_MAX + 1 == retval || !"Failed to convert 'INT_MAX + 1' to int(INT_MAX + 1)");

        libreport_set_map_string_item_from_uint(map, key, UINT_MAX);
        assert(libreport_try_get_map_string_item_as_uint(map, key, &retval) || !"Cannot return UINT_MAX");
        assert(retval == UINT_MAX || !"Garbled UINT_MAX");

        libreport_set_map_string_item_from_uint(map, key, 0);
        assert(libreport_try_get_map_string_item_as_uint(map, key, &retval) || !"Cannot return 0");
        assert(retval == 0 || !"Garbled 0");

        retval = 69;
        g_hash_table_replace(map, g_strdup(key), g_strdup(""));
        assert(!libreport_try_get_map_string_item_as_uint(map, key, &retval) || !"Converts '' to number");
        assert(retval == 69 || !"Modifies int(69) on ''");

        g_hash_table_replace(map, g_strdup(key), g_strdup("foo"));
        assert(!libreport_try_get_map_string_item_as_uint(map, key, &retval) || !"Converts 'foo' to number");
        assert(retval == 69 || !"Modifies int(69) on 'foo'");

        g_hash_table_replace(map, g_strdup(key), g_strdup("777foo"));
        assert(!libreport_try_get_map_string_item_as_uint(map, key, &retval) || !"Converts '777foo' to number");
        assert(retval == 69 || !"Modifies int(69) on '777foo'");

        g_hash_table_replace(map, g_strdup(key), g_strdup("77777777777777777777777777777777"));
        assert(!libreport_try_get_map_string_item_as_uint(map, key, &retval) || !"Converts '77777777777777777777777777777777' to number");
        assert(retval == 69 || !"Modifies int(69) on '77777777777777777777777777777777'");

        g_hash_table_replace(map, g_strdup(key), g_strdup("-1"));
        assert(!libreport_try_get_map_string_item_as_uint(map, key, &retval) || !"Converts '-1' to unsigned number");
        assert(retval == 69 || !"Modifies int(69) on '-1'");

        if (map)
            g_hash_table_destroy(map);
    }

    {
        const char *const key = "my_string";
        map_string_t *map = g_hash_table_new_full(g_str_hash, g_str_equal, free, free);

        char *retval = NULL;

        assert(!libreport_try_get_map_string_item_as_string(map, key, &retval) || !"Returns string(NULL) even if option does not exist");
        assert(retval == NULL || !"Modifies string(NULL) return value on failure");

        char *bck = g_strdup("test");
        retval = bck;

        assert(!libreport_try_get_map_string_item_as_string(map, key, &retval) || !"Returns string('test') even if option does not exist");
        assert(retval == bck || !"Modifies string('test') return value on failure");

        retval = g_strdup(bck);
        g_hash_table_replace(map, g_strdup(key), g_strdup(bck));

        free(bck);
        bck = retval;
        retval = NULL;

        assert(libreport_try_get_map_string_item_as_string(map, key, &retval) || !"Cannot return string('test')");
        assert(NULL != retval || !"The return value is not assigned to the return variable");
        assert(strcmp(bck, retval) == 0 || !"Garbled string('test') after freeing the original pointer");

        free(bck);
        free(retval);

        bck = g_strdup(key);

        g_hash_table_replace(map, g_strdup(bck), g_strdup("test"));
        free(bck);

        assert(libreport_try_get_map_string_item_as_string(map, key, &retval) || !"Cannot find key string('my_string') after freeing original key");
        assert(NULL != retval || !"The return value is not assigned to the return variable");
        assert(strcmp(bck, retval) == 0 || !"Garbled string('test') after freeing the original key value");

        /* TODO: try to store really big string */

        if (map)
            g_hash_table_destroy(map);
    }

    {
        const char *const key = "my_string_vector";
        map_string_t *map = g_hash_table_new_full(g_str_hash, g_str_equal, free, free);

        string_vector_ptr_t retval = NULL;

        assert(!libreport_try_get_map_string_item_as_string_vector(map, key, &retval) || !"Returns string_vector(NULL) even if option does not exist");
        assert(retval == NULL || !"Modifies string_vector(NULL) return value on failure");

        const char *const raw_value = "foo, blah, bang";
        string_vector_ptr_t vector = g_strsplit(raw_value, ", ", 0);

        libreport_set_map_string_item_from_string_vector(map, key, vector);

        assert(g_hash_table_lookup(map, key) || !"Set string_vector('foo, blah, bang')");
        assert(strcmp(raw_value, g_hash_table_lookup(map, key)) == 0 || !"Invalid string repr for string_vector('foo, blah, bang')");
        assert(libreport_try_get_map_string_item_as_string_vector(map, key, &retval) || !"Failed to return string_vector('foo, blah, bang')");
        assert(retval || !"Failed to convert 'foo, blah, bang' to string_vector('foo, blah, bang')");

        g_strfreev(vector);

        if (map)
            g_hash_table_destroy(map);
    }
}
]])
